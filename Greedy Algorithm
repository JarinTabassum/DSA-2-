//all the questions are in the greedy algorithm pdf file
//PROBLEM 01. Fractional knapsack

#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
struct Item{ //structure is how we gonna store the items in the vector
    int id;
    int weight;
    int value;
};
bool compare(Item a,Item b){ //the customized compare function
    double r1=(double)a.value/a.weight; //value per weight as value and weight is in integer, so making it double
    double r2=(double)b.value/b.weight;
    return r1>r2; //we will be returning the data in descending order 
}
double fractional_knapsack(int W,vector<Item>& items){
    sort(items.begin(),items.end(),compare); //then we called the sort function which will compare from beginning to end accroding to the custom compare function
    int cap_left=W; //at first the meximum amount will be the amount of the left capacity as nothing has been added yet
    double profit=0.0;
    for(int i=0;i<items.size();i++){ //from starting to the end of the vector items size
        if(cap_left<=0) break; //if there is no capacity left then break
            int wi=items[i].weight; //the highest ratio items weight according to the descending sorting and eventually the others
            int vi=items[i].value; 
            double fraction=min(1.0,(double)cap_left/wi); //as here we can take a whole item or some fraction of it, so the max limit will be 1
            cap_left-=fraction*wi; //multiplying the amount (0 to 1) to the actual weight to know how much of the particular item has been taken and then subtracting it to know how much is left
            profit+=fraction*vi;
            if(fraction>0){
                cout<<"Item number "<<items[i].id<<": "<<" weight: "<<fraction*wi<<" profit: "<<fraction*vi<<endl; 
        }
    }
    return profit; //will be returning the highest profit made by the algortihm
}
int main(){
    int n,W;
    cout<<"Enter the number of items:"<<endl;
    cin>>n;
    vector<Item> items(n);
    for(int i=0;i<n;i++){
        items[i].id=i+1; //so that every item can have a unique identifier id starting from 1
        cout<<"Enter weight and value:";
        cin>>items[i].weight>>items[i].value;
    }
    cout<<"Enter the maximum capacity:";
    cin>>W;
    double d=fractional_knapsack(W,items); //as parameter we will be passing the maximum ammount and the vector of items
    cout<<"Profit:"<<d;
}



//ALTERNATIVE QUESTION 01.1: Thieves in warehouse

#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
struct Item{ //structure for the vector
    string name;
    double weight;
    double value;
    double value_per_kg; 
};
bool compare(Item a,Item b){ //compare function in descending order
    return a.value_per_kg>b.value_per_kg;
}
int fractional_knapsack(vector<Item>& items,vector<double>& capacities){
    
    sort(items.begin(),items.end(),compare); //sorting the items in descending order according to their value per weight
    bool all_the_items_are_taken=false; //at first no items were stolen
    int total_thieves=0; //at first we had 0 thieves
    
    for(int i=0;i<capacities.size();i++){ //the amount of thieves the amount of capapcities size
        double profit=0.0;
        double capacity=capacities[i]; //iteratively picking capacity of each thief one after the other
        cout<<"Thief "<<i+1<<":"; //0+1=1
        
        for(auto& item:items){ //iteratively going through each item in the sorted items vector
        if(item.weight>0){ //if there is weight remaining to the item then
//also as we are using that for(auto& item:items) so we dont have to manually write items[i].weight or things we can somply write item.weight
            if(item.weight<=capacity){ //if the weight is less or equal to the capacity then take all of it
                cout<<"Taking the item "<<item.name<<": "<<" weight: "<<item.weight<<"kg  value: "<<item.value<<" taka "<<endl;
                capacity-=item.weight; //deducting thief's remaining capacity by the weight he took
                profit+=item.value; //adding the items value to profit as full of it was taken
                item.weight=0; //as it was less than capacity and all of it was taken so no weight is remaining to that item
            }
            else{ //if the item's weight is greater than capacity
                double taken_weight=capacity; //whicever capacity is left we will take that much amount of the itme
                double taken_value=taken_weight*item.value_per_kg; //value per kg multiply to how much we took as we didnt take the entire item
                cout<<"Taking the item "<<item.name<<": "<<" weight: "<<taken_weight<<" kg " <<" value:" <<taken_value<<"taka "<<endl;
                item.weight-=taken_weight; //item is still remaining but we took the remaining capapcity amount,so have to deduct that
                item.value-=taken_value; //decreases the remaining value as we took part of it
                profit+=taken_value;
                capacity=0; //as we filled the capacity with this item,so no capacity is left,knapsack is full
            }
            if(capacity==0){
                break; //knapsack full,get out
            }
        }
    }
    cout<<"Thief "<<i+1<<" profit:"<<profit<<" taka"<<endl<<endl; //prints the total profit gained by the current thief
    bool all_items_are_taken=true; //lets assume now all the items are taken by the thief
    for(auto& item:items){
        if(item.weight>0){ //lets iterate through each item,if any of its weight is left, then obviously not all item has been taken
            all_items_are_taken=false;
            break; //will go to the !all_the_items_are_taken part
        }
    }
    if(all_items_are_taken){ //all the items are taken
        total_thieves=i+1; //as we started from 0 index
        break;
    }
  }
  if(!all_the_items_are_taken){ //not all the items are taken
      total_thieves=capacities.size(); //all the thieves have come and completed their knapsack but still there are some item left
  }
  return total_thieves;
}
int main(){
    int n,k;
    cout<<"Enter the number of items:";
    cin>>n;
    vector<Item> items(n);
    for(int i=0;i<n;i++){
        cout<<"Enter the name,weight and value:";
        cin>>items[i].name>>items[i].value>>items[i].weight;
        items[i].value_per_kg=items[i].value/items[i].weight; //as we have taken this member in the structure of the vector, we have to initialize it
    }
    cout<<"Enter the number of thieves:";
    cin>>k;
    vector<double> capacities(k); //the number of thieves, the number of capacities
    for(int i=0;i<k;i++){
        cout<<"Enter capacity:";
        cin>>capacities[i];
    }
    int t=fractional_knapsack(items,capacities);
    cout<<"Total "<<t<<" number of thieves were needed"<<endl;
    for(const auto& item:items){
        if(item.weight>0){ //if there ares still some item left
            cout<<" Still there are left "<<item.name<<" "<<item.weight<<" kg "<<item.value<<" taka ";
        }
    }
}




//Problem 3 (Maximize your marks)
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
struct questions{
    int marks;
    int t;
    double marks_per_minute;
};
bool compare(questions A,questions B){
    return A.marks_per_minute>B.marks_per_minute;
}
void maximize(int Time,vector<questions>& q,bool with_friend){
    sort(q.begin(),q.end(),compare); //sorting the vector in ascending order
    double total_marks=0.0;
    int available_time=with_friend ? 2*Time : Time;
    //with a friend? if yes double the time : if not just the time
    vector<pair<int,double>> answered_questions;
    //int here will have the number of the question and the double will represent the percentage 
    for(int i=0;i<q.size();i++){
        if(q[i].t<=available_time){
            available_time-=q[i].t;
            total_marks+=q[i].marks;
            answered_questions.push_back({i+1,100.0}); //{} as pair, question number i+1 as i is starting from 0, as we have taken full of the question so 100%
        }
        else{ //remaining question will take more time than available time
            double fraction=(double)available_time/q[i].t;
            //as we are not answering the full question, how much did we answer
            available_time-=fraction; 
            total_marks+=q[i].marks*fraction;
            answered_questions.push_back({i+1,100*fraction});
            break; //as capacity is not left anymore so break it
        }
    }
    if(with_friend){
        cout<<" Maximum "<<total_marks<<" marks answering with a friend"<<endl;
    }
    else{
        cout<<"Maximum "<<total_marks<<" were answered all alone"<<endl;
    }
    for(auto& ans : answered_questions){
        cout<<"ques "<<ans.first<<" "<<ans.second<<"% done--"<<(q[ans.first-1].marks*ans.second/100)<<endl;
        //there are two parts(number and mark), ans.first means the question number and ans.second means marks of that question, q[ans.frist-1] as ans is starting from i+1 but question vector starts from 0 thats why -1, so that questions given mark * how much answered of the question/100 
    }
}
int main(){
    int Marks,Time,q_num;
    cout<<"Enter total marks,time and question number:";
    cin>>Marks>>Time>>q_num;
    vector<questions> q(q_num);
    for(int i=0;i<q_num;i++){
        cout<<"Enter marks and time:";
        cin>>q[i].marks>>q[i].t;
        q[i].marks_per_minute=(double)q[i].marks/q[i].t;
    }
    maximize(Time,q,false); //here as parameter we are taking total time,vector(which will take the marks and time of the individual questions) and with a friend or not bool
    for(int i=0;i<q_num;i++){ //resetting the marks per minute
        q[i].marks_per_minute=(double)q[i].marks/q[i].t;
    }
    maximize(Time,q,true);
}



//Activity Selection Problem
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
struct Activity{
    string name;
    int start_time;
    int end_time;
};
bool compare(Activity a,Activity b){
    return a.end_time<b.end_time;
    //whichever has the earliest finishing time will be at the first
}
void activity_selection(vector<Activity>& a){
    sort(a.begin(),a.end(),compare);
    vector<Activity> selected_act; //taking a vector which will have the selected activites
    selected_act.push_back(a[0]); //here out first element will be the first one after sorting as it has the earliest finishing time
    Activity last_selected=a[0]; //here we took a Activity varible which will store only the last selected activity
    for(int i=1;i<a.size();i++){
        if(a[i].start_time>=last_selected.end_time){
            //if ones starting time is more than the last chosen ones starting time than we can take it as it is not conflicting
            selected_act.push_back(a[i]);
            last_selected=a[i];
        }
    }
    for(auto& selected:selected_act){
        cout<<"name:"<<selected.name<<" start time:"<<selected.start_time<<" end time:"<<selected.end_time<<endl;
    }
}
int main(){
    int n;
    cout<<"Enter the number of events:";
    cin>>n;
    vector<Activity> activities(n);
    for(int i=0;i<n;i++){
        cout<<"Enter the name and starting and finishing time:";
        cin>>activities[i].name>>activities[i].start_time>>activities[i].end_time;
    }
    activity_selection(activities);
}


//ALTERNATIVE QUESTION 02.1: 
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
struct Activity{
    string name;
    int start_time;
    int duration;
    int end_time;
};
bool compare(Activity a,Activity b){
    return a.end_time<b.end_time;
    //whichever has the earliest finishing time will be at the first
}
void activity_selection(int break_time,vector<Activity>& a){
    sort(a.begin(),a.end(),compare);
    vector<Activity> selected_act; //taking a vector which will have the selected activites
    int last_selected_end_time=0; //at first as no item as selected so 0
    for(int i=0;i<a.size();i++){
        if(a[i].start_time>=last_selected_end_time){
            //if ones starting time is more than the last chosen ones starting time than we can take it as it is not conflicting
            selected_act.push_back(a[i]);
            last_selected_end_time=a[i].end_time+break_time; //adding the break time to the last selected ones end time
        }
    }
    for(auto& selected:selected_act){
        cout<<"name:"<<selected.name<<" start time:"<<selected.start_time<<" end time:"<<selected.end_time<<endl;
    }
}
int main(){
    int n,b;
    cout<<"Enter the number of events:";
    cin>>n;
    cout<<"Enter break time:";
    cin>>b;
    vector<Activity> activities(n);
    for(int i=0;i<n;i++){
        cout<<"Enter the name and starting and duration:";
        cin>>activities[i].name>>activities[i].start_time>>activities[i].duration;
        activities[i].end_time=activities[i].start_time+activities[i].duration; //start+duration=end
    }
    activity_selection(b,activities);
}


//Greedy Coin Change
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
void coin_change(int amount,vector<int>& coins){
    vector<pair<int,int>> result; //a pair vector to store the answer, first one will carry the coin value and the second one will hold how many of the coins will be needed
    int coin_taken=0;
    for(int i=0;i<coins.size();i++){
    while(amount>=coins[i]){
        int count=amount/coins[i]; //173/25=6 so 6 unit of 25 cents will be needed
        amount-=coins[i]*count; 
        result.push_back({coins[i],count}); 
        coin_taken+=count;
    }
    }
    for(auto& r:result){
        cout<<r.first<<" cents --- "<<r.second<<endl;
        //to write the vector pair's first element and second element
    }
    cout<<"Total coins used: "<<coin_taken<<endl;
}
int main(){
    int a,c;
    cout<<"Enter the amount:";
    cin>>a;
    cout<<"How many types of coins will be included:";
    cin>>c;
    vector<int> coins(c);
    for(int i=0;i<c;i++){
        cout<<"Enter the coin values:";
        cin>>coins[i];
    }
    sort(coins.rbegin(),coins.rend()); //rbegin and rend cz it is descending order (we need the most valued coin at first and eventually the rest ones)
    coin_change(a,coins);
}


//Finding minimum stops
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
void minimum_stops(int distance,int tank_life,vector<int>& gas_station){
    int current_position=0; //our current location
    int last_stop=0; //where we last stopped
    vector<int> stops;
    gas_station.push_back(distance);
    for(int i=0;i<gas_station.size();i++){
//if the distance from the last stopped gas station to the next stop is greater than how much a full tank go,then we cant reach the destination
        if(gas_station[i]-last_stop>tank_life){
            cout<<"Cant reach destination.";
            return;
        }
//if the current location to gas station is greater than the tank_life,then we need to stop at the last gas station within reach
        if(gas_station[i]-current_position>tank_life){
            stops.push_back(last_stop); //adding the last stopped station 
            current_position=last_stop; //current position will be the the last stopped station
        }
        last_stop=gas_station[i]; //changing last stop to the station 
    }
    cout<<"stop at gas station:"<<endl;
    for(int s:stops){
        cout<<"("<<s<<" miles )"<<endl;
    }
}
int main(){
    int distance,tank_life,stop_number;
    cout<<"Enter the total distance,tank life and number of stops:";
    cin>>distance>>tank_life>>stop_number;
    vector<int> gas_station(stop_number);
    for(int i=0;i<stop_number;i++){
        cout<<"Enter the gas stations:";
        cin>>gas_station[i];
    }
    sort(gas_station.begin(),gas_station.end());
    minimum_stops(distance,tank_life,gas_station);
}
