PROBLEM 01. Fractional knapsack
The weights and values of n items are given. The items are such that you can take a whole item or some
fraction of it (divisible). You have a knapsack to carry those items, whose weight capacity is W. Due to
the capacity limit of the knapsack, it might not be possible to carry all the items at once. In that case,
pick items such that the profit (total values of the taken items) is maximized.
Write a program that takes the weights and values of n items, and the capacity W of the knapsack from
the user and then finds the items which would maximize the profit using a greedy algorithm.

sample input
4 (number of items)
4 20  (weight and value)                                       
3 9
2 12
1 7
5 (maximum wieght)                   sample output
                                     item 4: 1.0 kg 7.0 taka
                                     item 3: 2.0 kg 12.0 taka
                                     item 1: 2.0 kg 10.0 taka
                                     profit: 29 taka


#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
struct Item{ //structure is how we gonna store the items in the vector
    int id;
    int weight;
    int value;
};
bool compare(Item a,Item b){ //the customized compare function
    double r1=(double)a.value/a.weight; //value per weight as value and weight is in integer, so making it double
    double r2=(double)b.value/b.weight;
    return r1>r2; //we will be returning the data in descending order 
}
double fractional_knapsack(int W,vector<Item>& items){
    sort(items.begin(),items.end(),compare); //then we called the sort function which will compare from beginning to end accroding to the custom compare function
    int cap_left=W; //at first the meximum amount will be the amount of the left capacity as nothing has been added yet
    double profit=0.0;
    for(int i=0;i<items.size();i++){ //from starting to the end of the vector items size
        if(cap_left<=0) break; //if there is no capacity left then break
            int wi=items[i].weight; //the highest ratio items weight according to the descending sorting and eventually the others
            int vi=items[i].value; 
            double fraction=min(1.0,(double)cap_left/wi); //as here we can take a whole item or some fraction of it, so the max limit will be 1
            cap_left-=fraction*wi; //multiplying the amount (0 to 1) to the actual weight to know how much of the particular item has been taken and then subtracting it to know how much is left
            profit+=fraction*vi;
            if(fraction>0){
                cout<<"Item number "<<items[i].id<<": "<<" weight: "<<fraction*wi<<" profit: "<<fraction*vi<<endl; 
        }
    }
    return profit; //will be returning the highest profit made by the algortihm
}
int main(){
    int n,W;
    cout<<"Enter the number of items:"<<endl;
    cin>>n;
    vector<Item> items(n);
    for(int i=0;i<n;i++){
        items[i].id=i+1; //so that every item can have a unique identifier id starting from 1
        cout<<"Enter weight and value:";
        cin>>items[i].weight>>items[i].value;
    }
    cout<<"Enter the maximum capacity:";
    cin>>W;
    double d=fractional_knapsack(W,items); //as parameter we will be passing the maximum ammount and the vector of items
    cout<<"Profit:"<<d;
}







