//all the questions are in the greedy algorithm pdf file
//PROBLEM 01. Fractional knapsack

#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
struct Item{ //structure is how we gonna store the items in the vector
    int id;
    int weight;
    int value;
};
bool compare(Item a,Item b){ //the customized compare function
    double r1=(double)a.value/a.weight; //value per weight as value and weight is in integer, so making it double
    double r2=(double)b.value/b.weight;
    return r1>r2; //we will be returning the data in descending order 
}
double fractional_knapsack(int W,vector<Item>& items){
    sort(items.begin(),items.end(),compare); //then we called the sort function which will compare from beginning to end accroding to the custom compare function
    int cap_left=W; //at first the meximum amount will be the amount of the left capacity as nothing has been added yet
    double profit=0.0;
    for(int i=0;i<items.size();i++){ //from starting to the end of the vector items size
        if(cap_left<=0) break; //if there is no capacity left then break
            int wi=items[i].weight; //the highest ratio items weight according to the descending sorting and eventually the others
            int vi=items[i].value; 
            double fraction=min(1.0,(double)cap_left/wi); //as here we can take a whole item or some fraction of it, so the max limit will be 1
            cap_left-=fraction*wi; //multiplying the amount (0 to 1) to the actual weight to know how much of the particular item has been taken and then subtracting it to know how much is left
            profit+=fraction*vi;
            if(fraction>0){
                cout<<"Item number "<<items[i].id<<": "<<" weight: "<<fraction*wi<<" profit: "<<fraction*vi<<endl; 
        }
    }
    return profit; //will be returning the highest profit made by the algortihm
}
int main(){
    int n,W;
    cout<<"Enter the number of items:"<<endl;
    cin>>n;
    vector<Item> items(n);
    for(int i=0;i<n;i++){
        items[i].id=i+1; //so that every item can have a unique identifier id starting from 1
        cout<<"Enter weight and value:";
        cin>>items[i].weight>>items[i].value;
    }
    cout<<"Enter the maximum capacity:";
    cin>>W;
    double d=fractional_knapsack(W,items); //as parameter we will be passing the maximum ammount and the vector of items
    cout<<"Profit:"<<d;
}



//ALTERNATIVE QUESTION 01.1: Thieves in warehouse

#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
struct Item{ //structure for the vector
    string name;
    double weight;
    double value;
    double value_per_kg; 
};
bool compare(Item a,Item b){ //compare function in descending order
    return a.value_per_kg>b.value_per_kg;
}
int fractional_knapsack(vector<Item>& items,vector<double>& capacities){
    
    sort(items.begin(),items.end(),compare); //sorting the items in descending order according to their value per weight
    bool all_the_items_are_taken=false; //at first no items were stolen
    int total_thieves=0; //at first we had 0 thieves
    
    for(int i=0;i<capacities.size();i++){ //the amount of thieves the amount of capapcities size
        double profit=0.0;
        double capacity=capacities[i]; //iteratively picking capacity of each thief one after the other
        cout<<"Thief "<<i+1<<":"; //0+1=1
        
        for(auto& item:items){ //iteratively going through each item in the sorted items vector
        if(item.weight>0){ //if there is weight remaining to the item then
//also as we are using that for(auto& item:items) so we dont have to manually write items[i].weight or things we can somply write item.weight
            if(item.weight<=capacity){ //if the weight is less or equal to the capacity then take all of it
                cout<<"Taking the item "<<item.name<<": "<<" weight: "<<item.weight<<"kg  value: "<<item.value<<" taka "<<endl;
                capacity-=item.weight; //deducting thief's remaining capacity by the weight he took
                profit+=item.value; //adding the items value to profit as full of it was taken
                item.weight=0; //as it was less than capacity and all of it was taken so no weight is remaining to that item
            }
            else{ //if the item's weight is greater than capacity
                double taken_weight=capacity; //whicever capacity is left we will take that much amount of the itme
                double taken_value=taken_weight*item.value_per_kg; //value per kg multiply to how much we took as we didnt take the entire item
                cout<<"Taking the item "<<item.name<<": "<<" weight: "<<taken_weight<<" kg " <<" value:" <<taken_value<<"taka "<<endl;
                item.weight-=taken_weight; //item is still remaining but we took the remaining capapcity amount,so have to deduct that
                item.value-=taken_value; //decreases the remaining value as we took part of it
                profit+=taken_value;
                capacity=0; //as we filled the capacity with this item,so no capacity is left,knapsack is full
            }
            if(capacity==0){
                break; //knapsack full,get out
            }
        }
    }
    cout<<"Thief "<<i+1<<" profit:"<<profit<<" taka"<<endl<<endl; //prints the total profit gained by the current thief
    bool all_items_are_taken=true; //lets assume now all the items are taken by the thief
    for(auto& item:items){
        if(item.weight>0){ //lets iterate through each item,if any of its weight is left, then obviously not all item has been taken
            all_items_are_taken=false;
            break; //will go to the !all_the_items_are_taken part
        }
    }
    if(all_items_are_taken){ //all the items are taken
        total_thieves=i+1; //as we started from 0 index
        break;
    }
  }
  if(!all_the_items_are_taken){ //not all the items are taken
      total_thieves=capacities.size(); //all the thieves have come and completed their knapsack but still there are some item left
  }
  return total_thieves;
}
int main(){
    int n,k;
    cout<<"Enter the number of items:";
    cin>>n;
    vector<Item> items(n);
    for(int i=0;i<n;i++){
        cout<<"Enter the name,weight and value:";
        cin>>items[i].name>>items[i].value>>items[i].weight;
        items[i].value_per_kg=items[i].value/items[i].weight; //as we have taken this member in the structure of the vector, we have to initialize it
    }
    cout<<"Enter the number of thieves:";
    cin>>k;
    vector<double> capacities(k); //the number of thieves, the number of capacities
    for(int i=0;i<k;i++){
        cout<<"Enter capacity:";
        cin>>capacities[i];
    }
    int t=fractional_knapsack(items,capacities);
    cout<<"Total "<<t<<" number of thieves were needed"<<endl;
    for(const auto& item:items){
        if(item.weight>0){ //if there ares still some item left
            cout<<" Still there are left "<<item.name<<" "<<item.weight<<" kg "<<item.value<<" taka ";
        }
    }
}




//Problem 3
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
struct questions{
    int marks;
    int t;
    double marks_per_minute;
};
bool compare(questions A,questions B){
    return A.marks_per_minute>B.marks_per_minute;
}
void maximize(int Time,vector<questions>& q,bool with_friend){
    sort(q.begin(),q.end(),compare); //sorting the vector in ascending order
    double total_marks=0.0;
    int available_time=with_friend ? 2*Time : Time;
    //with a friend? if yes double the time : if not just the time
    vector<pair<int,double>> answered_questions;
    //int here will have the number of the question and the double will represent the percentage 
    for(int i=0;i<q.size();i++){
        if(q[i].t<=available_time){
            available_time-=q[i].t;
            total_marks+=q[i].marks;
            answered_questions.push_back({i+1,100.0}); //{} as pair, question number i+1 as i is starting from 0, as we have taken full of the question so 100%
        }
        else{ //remaining question will take more time than available time
            double fraction=(double)available_time/q[i].t;
            //as we are not answering the full question, how much did we answer
            available_time-=fraction; 
            total_marks+=q[i].marks*fraction;
            answered_questions.push_back({i+1,100*fraction});
            break; //as capacity is not left anymore so break it
        }
    }
    if(with_friend){
        cout<<" Maximum "<<total_marks<<" marks answering with a friend"<<endl;
    }
    else{
        cout<<"Maximum "<<total_marks<<" were answered all alone"<<endl;
    }
    for(auto& ans : answered_questions){
        cout<<"ques "<<ans.first<<" "<<ans.second<<"% done--"<<(q[ans.first-1].marks*ans.second/100)<<endl;
        //there are two parts(number and mark), ans.first means the question number and ans.second means marks of that question, q[ans.frist-1] as ans is starting from i+1 but question vector starts from 0 thats why -1, so that questions given mark * how much answered of the question/100 
    }
}
int main(){
    int Marks,Time,q_num;
    cout<<"Enter total marks,time and question number:";
    cin>>Marks>>Time>>q_num;
    vector<questions> q(q_num);
    for(int i=0;i<q_num;i++){
        cout<<"Enter marks and time:";
        cin>>q[i].marks>>q[i].t;
        q[i].marks_per_minute=(double)q[i].marks/q[i].t;
    }
    maximize(Time,q,false); //here as parameter we are taking total time,vector(which will take the marks and time of the individual questions) and with a friend or not bool
    for(int i=0;i<q_num;i++){ //resetting the marks per minute
        q[i].marks_per_minute=(double)q[i].marks/q[i].t;
    }
    maximize(Time,q,true);
}


